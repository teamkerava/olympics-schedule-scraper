---
interface ScheduleEvent {
  time: string;
  event: string;
  sport: string;
  venue: string;
  teams?: string;
  status?: string;
}

interface DaySchedule {
  date: string;
  events: ScheduleEvent[];
}

import fs from 'fs';
import path from 'path';

// Load JSON files preferring project root copies when available (useful for built deployments).
function loadJsonPreferRoot<T = any>(rootFilename: string, fallbackRel: string): T {
  // Try several locations in order:
  // 1) process.cwd()/rootFilename (CI/root-level copy)
  // 2) process.cwd()/public/rootFilename (when scraper writes to public/)
  // 3) fallback relative to this file (dev: src/data)
  // If nothing works return a safe default ({} or []).
  const tryPaths = [
    path.join(process.cwd(), rootFilename),
    path.join(process.cwd(), 'public', rootFilename)
  ];

  for (const p of tryPaths) {
    try {
      if (fs.existsSync(p)) {
        const content = fs.readFileSync(p, 'utf8');
        return JSON.parse(content) as T;
      }
    } catch (e) {
      // ignore and continue to next candidate
    }
  }

  // Fall back to a path relative to this file (works in dev)
  try {
    const url = new URL(fallbackRel, import.meta.url);
    if (fs.existsSync(url)) {
      const content = fs.readFileSync(url, 'utf8');
      return JSON.parse(content) as T;
    }
    // Node's fs.existsSync doesn't accept URL in some runtimes; try reading anyway
    const content = fs.readFileSync(url, 'utf8');
    return JSON.parse(content) as T;
  } catch (e) {
    // return a safe empty value: array for schedule files, object otherwise
    // caller will normalize further.
    return (Array.isArray(([] as unknown)) ? ([] as unknown as T) : ({} as T));
  }
}

let scheduleData = loadJsonPreferRoot('schedule.json', '../data/schedule.json');
// If the returned value isn't an array, try a few more fallbacks and finally coerce to an empty array.
if (!Array.isArray(scheduleData)) {
  scheduleData = loadJsonPreferRoot('public/schedule.json', '../data/schedule.json');
}
if (!Array.isArray(scheduleData)) scheduleData = [] as unknown as typeof scheduleData;

let finnishAthletesData = loadJsonPreferRoot('finnish-athletes.json', '../data/finnish-athletes.json') || [];
// Fallback: if a dedicated finnish-athletes.json isn't available, try to derive
// a simple athletes list from finnish-schedule.json which some scrapers produce.
if ((!Array.isArray(finnishAthletesData) || (finnishAthletesData as any[]).length === 0)) {
  try {
    const maybeSchedule = loadJsonPreferRoot('finnish-schedule.json', '../data/finnish-schedule.json');
    if (Array.isArray(maybeSchedule) && maybeSchedule.length > 0) {
      const derived: any[] = [];
      for (const day of maybeSchedule) {
        const date = day.date;
        if (!Array.isArray(day.events)) continue;
        for (const ev of day.events) {
          if (!ev || !ev.athletes) continue;
          const names = (ev.athletes || '').split(',').map((s: string) => s.trim()).filter(Boolean);
          for (const nm of names) {
            derived.push({ date, athletes: [{ athlete: nm, sport: ev.sport || '', event: ev.event || '', time: ev.time || '', dateIso: '', eventIso: '' }] });
          }
        }
      }
      // Convert derived array into grouped structure per-date
      const grouped = new Map();
      for (const item of derived) {
        const d = item.date || '';
        if (!grouped.has(d)) grouped.set(d, []);
        for (const a of item.athletes) grouped.get(d).push(a);
      }
      const days = Array.from(grouped.entries()).map(([date, athletes]) => ({ date, athletes }));
      finnishAthletesData = days;
    }
  } catch (e) {
    // ignore fallback errors
  }
}
// last-updated is usually written to public/last-updated.json by the scraper; try several locations
const lastUpdated = loadJsonPreferRoot('last-updated.json', '../../public/last-updated.json') || {};

interface FinnishAthlete {
  time: string;
  sport: string;
  athlete: string;
  event: string;
  dateIso?: string;
  eventIso?: string;
}

interface FinnishAthletesDay {
  date: string;
  athletes: FinnishAthlete[];
}

/* Removed unused FinlandEvent/FinlandEventsDay types (no longer needed) */

function parseDate(dateStr: string): Date {
  const match = dateStr.match(/(\w+)\s+(\d+),\s+(\d{4})/);
  if (match) {
    const months: Record<string, number> = {
      'January': 0, 'February': 1, 'March': 2, 'April': 3, 'May': 4, 'June': 5,
      'July': 6, 'August': 7, 'September': 8, 'October': 9, 'November': 10, 'December': 11
    };
    return new Date(parseInt(match[3]), months[match[1]] || 0, parseInt(match[2]));
  }
  return new Date(0);
}

const today = new Date();
const todayStr = today.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });

// Find schedule for today; if none exists, fall back to the first available day
const currentDay = (scheduleData as DaySchedule[]).find((d: DaySchedule) => d.date === todayStr) || (scheduleData as DaySchedule[])[0];
// Display date should reflect the day we are actually showing (today or fallback)
const displayDate = currentDay?.date || todayStr;
const currentFinnishDay = (finnishAthletesData as FinnishAthletesDay[]).find((d: FinnishAthletesDay) => d.date === displayDate) || undefined;

function formatDate(dateStr: string): string {
  const date = parseDate(dateStr);
  if (date.getTime() === 0) return dateStr;

  const day = date.getDate();
  const month = date.toLocaleDateString('en-US', { month: 'long' });
  const weekday = date.toLocaleDateString('en-US', { weekday: 'long' });

  // Format like: "February 5, Thursday"
  return `${month} ${day}, ${weekday}`;
}

function formatTime(timeStr: string): string {
  if (!timeStr || timeStr === 'TBD') return timeStr;
  return timeStr.split(/\s/)[0];
}

const countryEmojiMap: Record<string, string> = {
  'Germany': 'üá©üá™', 'Korea': 'üá∞üá∑', 'Norway': 'üá≥üá¥', 'Czechia': 'üá®üáø', 'Switzerland': 'üá®üá≠',
  'Ukraine': 'üá∫üá¶', 'Estonia': 'üá™üá™', 'Sweden': 'üá∏üá™', 'United States': 'üá∫üá∏', 'Canada': 'üá®üá¶',
  'Great Britain': 'üá¨üáß', 'Italy': 'üáÆüáπ', 'France': 'üá´üá∑', 'Austria': 'üá¶üáπ', 'Slovenia': 'üá∏üáÆ',
  'Japan': 'üáØüáµ', 'China': 'üá®üá≥', 'New Zealand': 'üá≥üáø', 'Australia': 'üá¶üá∫', 'Finland': 'üá´üáÆ',
  'ROC': 'üá∑üá∫', 'Kazakhstan': 'üá∞üáø', 'Poland': 'üáµüá±', 'Belarus': 'üáßüáæ', 'Latvia': 'üá±üáª',
  'Lithuania': 'üá±üáπ', 'Denmark': 'üá©üá∞', 'Netherlands': 'üá≥üá±', 'Belgium': 'üáßüá™', 'Ireland': 'üáÆüá™',
  'Spain': 'üá™üá∏', 'Portugal': 'üáµüáπ', 'Brazil': 'üáßüá∑', 'Argentina': 'üá¶üá∑', 'Mexico': 'üá≤üáΩ',
  'South Africa': 'üáøüá¶', 'Philippines': 'üáµüá≠', 'Chinese Taipei': 'üáπüáº', 'Hong Kong': 'üá≠üá∞',
  'Indonesia': 'üáÆüá©', 'Malaysia': 'üá≤üáæ', 'Singapore': 'üá∏üá¨', 'Thailand': 'üáπüá≠', 'Vietnam': 'üáªüá≥',
  'India': 'üáÆüá≥', 'Pakistan': 'üáµüá∞', 'Bangladesh': 'üáßüá©', 'Sri Lanka': 'üá±üá∞', 'Nepal': 'üá≥üáµ',
  'Mongolia': 'üá≤üá≥', 'Qatar': 'üá∂üá¶', 'UAE': 'üá¶üá™', 'Saudi Arabia': 'üá∏üá¶', 'Turkey': 'üáπüá∑',
  'Israel': 'üáÆüá±', 'Egypt': 'üá™üá¨', 'Morocco': 'üá≤üá¶', 'Tunisia': 'üáπüá≥', 'Algeria': 'üá©üáø',
  'Nigeria': 'üá≥üá¨', 'Ghana': 'üá¨üá≠', 'Senegal': 'üá∏üá≥', 'Cambodia': 'üá∞üá≠', 'Jordan': 'üáØüá¥',
  'Lebanon': 'üá±üáß', 'Syria': 'üá∏üáæ', 'Iraq': 'üáÆüá∂', 'Kuwait': 'üá∞üáº', 'Oman': 'üá¥üá≤',
  'Bahrain': 'üáßüá≠', 'Iceland': 'üáÆüá∏', 'Luxembourg': 'üá±üá∫', 'Monaco': 'üá≤üá®', 'Andorra': 'üá¶üá©',
  'San Marino': 'üá∏üá≤', 'Malta': 'üá≤üáπ', 'Cyprus': 'üá®üáæ', 'Armenia': 'üá¶üá≤', 'Georgia': 'üá¨üá™',
  'Azerbaijan': 'üá¶üáø', 'Kosovo': 'üáΩüá∞', 'North Macedonia': 'üá≤üá∞', 'Albania': 'üá¶üá±', 'Bosnia': 'üáßüá¶',
  'Montenegro': 'üá≤üá™', 'Serbia': 'üá∑üá™', 'Croatia': 'üá≠üá∑', 'Slovakia': 'üá∏üá∞', 'Bulgaria': 'üáßüá¨',
  'Romania': 'üá∑üá¥', 'Hungary': 'üá≠üá∫'
};

function addCountryEmoji(teams: string): string {
  if (!teams) return '';
  return teams.split(' vs ').map(team => {
    const emoji = countryEmojiMap[team.trim()];
    return emoji ? `${emoji} ${team}` : team;
  }).join(' vs ');
}

function parseTime(timeStr?: string): Date | null {
  if (!timeStr || timeStr === 'TBD') return null;
  const timePart = (timeStr || '').split(/\s/)[0];
  const match = timePart.match(/(\d+):(\d+)/);
  if (match) {
    let hours = parseInt(match[1]);
    const minutes = parseInt(match[2]);
    if (timeStr.toLowerCase().includes('pm') && hours !== 12) {
      hours += 12;
    } else if (timeStr.toLowerCase().includes('am') && hours === 12) {
      hours = 0;
    }
    const now = new Date();
    return new Date(now.getFullYear(), now.getMonth(), now.getDate(), hours, minutes);
  }
  return null;
}

// Create a Date object for the exact instant when the wall clock in `timeZone`
// reads the supplied year/month/day/hour/minute. This mirrors the client-side
// conversion so server-side (SSR/build) instants match the browser's.
/* Removed timezone-aware server conversion. We treat provided date+time as a
   plain wall-clock local date/time (no Europe/Rome adjustments). */

function isInProgress(timeStr: string): boolean {
  const eventTime = parseTime(timeStr);
  if (!eventTime) return false;
  const now = new Date();
  const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
  return eventTime >= oneHourAgo && eventTime <= now;
}

function isEnded(timeStr: string): boolean {
  const eventTime = parseTime(timeStr);
  if (!eventTime) return false;
  const now = new Date();
  const endedThreshold = new Date(eventTime.getTime() + 2 * 60 * 60 * 1000); // 2 hours after start
  return now > endedThreshold;
}

// Prefer ISO event instants when available. If an ISO timestamp (with timezone)
// is provided we parse it directly. Otherwise, fall back to combining the
// provided dateIso and time string. If that also fails, return null.
function parseEventInstant(eventIso?: string, dateIso?: string, timeStr?: string): Date | null {
  if (eventIso) {
    const d = new Date(eventIso);
    if (!isNaN(d.getTime())) return d;
  }
  const timePart = (timeStr || '').split(/\s/)[0];
  if (dateIso && timePart) {
    // Treat the provided dateIso + time as a plain wall-clock local date/time
    // (no timezone conversions). Construct with the Date(year, month-1, ..)
    // constructor so the instant corresponds to that local wall-clock.
    try {
      const [y, m, d] = dateIso.split('-').map(v => parseInt(v, 10));
      const [hh, mm] = timePart.split(':').map(v => parseInt(v, 10));
      if (!Number.isNaN(y) && !Number.isNaN(m) && !Number.isNaN(d) && !Number.isNaN(hh) && !Number.isNaN(mm)) {
        return new Date(y, m - 1, d, hh, mm);
      }
    } catch (e) {
      // fall back to naive parse below
    }
    const combined = `${dateIso}T${timePart}:00`;
    const d2 = new Date(combined);
    if (!isNaN(d2.getTime())) return d2;
  }
  return null;
}

function isInProgressFromIso(eventIso?: string, dateIso?: string, timeStr?: string): boolean {
  const eventTime = parseEventInstant(eventIso, dateIso, timeStr) || parseTime(timeStr);
  if (!eventTime) return false;
  const now = new Date();
  const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
  return eventTime >= oneHourAgo && eventTime <= now;
}

function isEndedFromIso(eventIso?: string, dateIso?: string, timeStr?: string): boolean {
  const eventTime = parseEventInstant(eventIso, dateIso, timeStr) || parseTime(timeStr);
  if (!eventTime) return false;
  const now = new Date();
  const endedThreshold = new Date(eventTime.getTime() + 2 * 60 * 60 * 1000);
  return now > endedThreshold;
}

const formattedDate = formatDate(displayDate);
// expose ISO date for client-side timezone conversions. Build the ISO date
// directly from the displayDate string so we don't depend on local-midnight
// Date -> toISOString() which can shift the day depending on server TZ.
function isoFromDisplayDate(display: string): string {
  const m = display.match(/(\w+)\s+(\d+),\s+(\d{4})/);
  if (!m) return '';
  const months: Record<string, number> = {
    'January': 1, 'February': 2, 'March': 3, 'April': 4, 'May': 5, 'June': 6,
    'July': 7, 'August': 8, 'September': 9, 'October': 10, 'November': 11, 'December': 12
  };
  const month = months[m[1]] || 1;
  const day = parseInt(m[2], 10);
  const year = parseInt(m[3], 10);
  return `${year.toString().padStart(4,'0')}-${month.toString().padStart(2,'0')}-${day.toString().padStart(2,'0')}`;
}
const currentDateIso = isoFromDisplayDate(displayDate);
const todaysEvents = currentDay?.events || [];
const todaysFinnishAthletes = currentFinnishDay?.athletes || [];
// Filter out events that are finished. Prefer an explicit status check when available
// (some schedule entries include 'status' like FINISHED/ENDED), otherwise fall back
// to the time-based ended heuristic.
const filteredEvents = todaysEvents.filter((event: ScheduleEvent) => {
  try {
    const status = (event.status || '').toString();
    // Always drop explicit finished/ended markers
    if (status && /finished|ended|completed/i.test(status)) return false;
    // If status explicitly says scheduled or in-progress, keep it
    if (status && /scheduled/i.test(status)) return true;
    if (status && /in\s*progress|in_progress|inprogress/i.test(status)) return true;

    // Otherwise, prefer ISO-aware ended check if available, fall back to time-only
    // @ts-ignore - schedule events may optionally include eventIso/dateIso
    const ended = isEndedFromIso((event as any).eventIso || '', (event as any).dateIso || currentDateIso, event.time || '');
    return !ended;
  } catch {
    return !isEnded(event.time);
  }
});
// Include all Finnish athletes for the day so users can glance who competed today,
// even if the event is finished. Keep entries that have at least an athlete name.
const filteredFinnishAthletes = (() => {
  const raws = todaysFinnishAthletes.filter((a: FinnishAthlete) => a.athlete && a.athlete.trim());

  // Group by athlete name and pick the best entry when duplicates exist.
  const byName = new Map<string, FinnishAthlete[]>();
  raws.forEach((a: FinnishAthlete) => {
    const key = a.athlete.trim();
    if (!byName.has(key)) byName.set(key, []);
    byName.get(key)!.push(a);
  });

  const isEventLikeName = (ev?: string, athleteName?: string) => {
    if (!ev || !athleteName) return false;
    const normalize = (s: string) => s.replace(/\s+/g, '').toLowerCase();
    const e = normalize(ev);
    const a = normalize(athleteName);
    return e === a || e.includes(a) || a.includes(e);
  };

  const result: FinnishAthlete[] = [];
  for (const [_, items] of byName.entries()) {
    if (items.length === 1) {
      result.push(items[0]);
      continue;
    }

    // Score entries by how informative they are: time > sport > eventIso > event
    const score = (it: FinnishAthlete) => (it.time && it.time.trim() ? 8 : 0) + (it.sport && it.sport.trim() ? 4 : 0) + ((it as any).eventIso ? 2 : 0) + (it.event && it.event.trim() ? 1 : 0);
    // Prefer entries with a higher score
    items.sort((a, b) => score(b) - score(a));

    // Prefer an entry whose 'event' is not merely the athlete's name (sometimes the feed contains a reversed name row)
    let chosen = items[0];
    if ((!chosen.time && !chosen.sport) && chosen.event) {
      const alt = items.find(it => (it.time || it.sport || (it as any).eventIso) && !isEventLikeName(it.event, it.athlete));
      if (alt) chosen = alt;
    }

    result.push(chosen);
  }

  return result;
})();

// Global live events for today (all events, regardless of filteredEvents). Use
// explicit status 'IN PROGRESS' when present, otherwise fall back to ISO/time check.
const liveAllEvents = todaysEvents.filter((event: ScheduleEvent) => {
  try {
    const status = (event.status || '').toString();
    if (status && /in\s*progress|in_progress|inprogress/i.test(status)) return true;
    return isInProgressFromIso((event as any).eventIso || '', (event as any).dateIso || currentDateIso, event.time || '');
  } catch {
    return isInProgress(event.time);
  }
});

// All events explicitly marked as finished/ended/completed (global), sorted newest first
// Treat finished/ended/completed and cancelled as past events
const pastEventsAll = (todaysEvents || []).filter((e: ScheduleEvent) => {
  const status = ((e as any).status || '').toString();
  return status && /finished|ended|completed|cancel|cancelled/i.test(status);
});
pastEventsAll.sort((a: ScheduleEvent, b: ScheduleEvent) => {
  const ta = parseEventInstant((a as any).eventIso || '', (a as any).dateIso || currentDateIso, a.time) || parseTime(a.time) || new Date(0);
  const tb = parseEventInstant((b as any).eventIso || '', (b as any).dateIso || currentDateIso, b.time) || parseTime(b.time) || new Date(0);
  return (ta as Date).getTime() - (tb as Date).getTime();
});

// lastUpdated is expected to be an object like { iso: "2026-02-05T14:18:31.000Z" }
const lastUpdatedIso = (lastUpdated as { iso?: string })?.iso || '';
// Use en-GB locale to format date as DD/MM/YYYY (and include time)
const formattedLastUpdated = lastUpdatedIso ? `Last updated: ${new Date(lastUpdatedIso).toLocaleString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' })}` : 'Data updated every 5 minutes';
---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>Milano Cortina 2026 - Today's Schedule</title>
    <style>
      * { box-sizing: border-box; margin: 0; padding: 0; }
      body { font-family: system-ui, sans-serif; background: #f5f5f5; min-height: 100vh; }
      .container { position: relative; max-width: 1200px; margin: 0 auto; padding: 20px; }
      header { text-align: center; margin-bottom: 30px; }
      h1 { color: #1a1a2e; margin-bottom: 8px; }
      .subtitle { color: #666; }
      .current-date { text-align: center; font-size: 22px; font-weight: bold; color: #333; margin: 20px 0; }
      .two-columns { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
      @media (max-width: 768px) { .two-columns { grid-template-columns: 1fr; } }
      .schedule { background: white; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); overflow: hidden; }
      .section-title { font-size: 18px; font-weight: bold; color: #333; margin-bottom: 12px; padding-left: 4px; }
      .finnish-title { color: #003399; }
      .event { padding: 16px 20px; border-bottom: 1px solid #eee; display: grid; grid-template-columns: 80px 1fr; gap: 16px; }
      .event:last-child { border-bottom: none; }
      .event-time { color: #003399; font-weight: bold; font-size: 15px; }
      .event-details h3 { font-size: 16px; margin-bottom: 4px; color: #333; display: flex; align-items: center; }
      .event-sport { color: #666; font-size: 14px; }
      .event-venue { color: #888; font-size: 12px; margin-top: 4px; }
      .event-teams { color: #003399; font-size: 14px; margin-top: 4px; font-weight: 500; }
      .empty { text-align: center; padding: 40px; color: #666; }
      .finnish-athlete { color: #333; font-size: 14px; margin-bottom: 4px; font-weight: 600; }
      .finnish-schedule { background: linear-gradient(135deg, #ffffff 0%, #f0f5ff 100%); overflow: hidden; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
      .finnish-event { padding: 14px 16px; border-bottom: 1px solid rgba(0,0,0,0.08); display: grid; grid-template-columns: 70px 1fr; gap: 12px; }
      .finnish-event:last-child { border-bottom: none; }
      .finnish-event-time { color: #003399; font-weight: bold; font-size: 15px; }
      .finnish-event-details h3 { font-size: 15px; margin-bottom: 3px; color: #333; display: flex; align-items: center; }
      .finnish-event-sport { color: #666; font-size: 13px; font-weight: 500; }
      .finnish-empty { text-align: center; padding: 30px; color: #666; }
      .timezone-note { position: left; font-size: 12px; color: #000; margin-top: 8px; }
      .update-note { position: absolute; top: 12px; right: 20px; background: rgba(255,255,255,0.9); color: #333; font-size: 12px; padding: 6px 10px; border-radius: 10px; box-shadow: 0 1px 4px rgba(0,0,0,0.08); }
      .in-progress-badge { display: inline-block; background: #d32f2f; color: white; font-size: 10px; padding: 2px 6px; border-radius: 4px; margin-left: 8px; font-weight: bold; text-transform: uppercase; animation: pulse 2s infinite; }
      .ended-badge { display: inline-block; background: #666; color: white; font-size: 10px; padding: 2px 6px; border-radius: 4px; margin-left: 8px; font-weight: 600; text-transform: uppercase; }
      @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }
      .cancelled-badge { display: inline-block; background: #ff9800; color: white; font-size: 10px; padding: 2px 6px; border-radius: 4px; margin-left: 8px; font-weight: bold; text-transform: uppercase; animation: pulse 2s infinite; }
    </style>
    <!-- Timezone conversions removed: show times exactly as provided in schedule.json -->
  </head>
  <body>
    <div class="container">
      <div class="timezone-note">All times are provided in Central European Time (CET)</div>
      <header>
        <h1>üèÖ Milano Cortina 2026</h1>
        <p class="subtitle">Winter Olympics Schedule from Olympics.com</p>
      </header>
      <div class="update-note">{formattedLastUpdated}</div>
      <div class="current-date">{formattedDate}</div>

      <!-- Global live events for the day (full-width) -->
      <div class="live-global" style="margin: 18px 0;">
        <div class="section-title">Live Now</div>
        <div class="schedule">
          {
            (() => {
              if (!liveAllEvents || liveAllEvents.length === 0) {
                return (<div class="empty">No live events right now</div>);
              }

              return (
                <div>
                  {liveAllEvents.map((event: ScheduleEvent) => (
                    <div class="event">
                      <div class="event-time"><span class="time" data-time={event.time} data-date-iso={(event as any).dateIso || currentDateIso}>{formatTime(event.time)}</span></div>
                      <div class="event-details">
                        <h3>
                          {event.event}
                          <span class="in-progress-badge">LIVE</span>
                          {event.status && /cancel/i.test(event.status) && (
                            <span class="cancelled-badge">CANCELLED</span>
                          )}
                        </h3>
                        <p class="event-sport">{event.sport}</p>
                        {event.venue && <p class="event-venue">üìç {event.venue}</p>}
                        {event.teams && <p class="event-teams">{addCountryEmoji(event.teams)}</p>}
                      </div>
                    </div>
                  ))}
                </div>
              );
            })()
          }
        </div>
      </div>

      <div class="two-columns">
        <div class="finnish-column">
          <div class="section-title finnish-title">üá´üáÆ Finnish Athletes</div>
           <div class="finnish-schedule">
               {
                 (() => {
                   // Show all Finnish athletes for the day in a single list (sorted by time when possible).
                   const entries = filteredFinnishAthletes.slice().sort((a: FinnishAthlete, b: FinnishAthlete) => {
                     const ta = parseEventInstant((a as any).eventIso || '', a.dateIso || currentDateIso, a.time) || parseTime(a.time) || new Date(8640000000000000);
                     const tb = parseEventInstant((b as any).eventIso || '', b.dateIso || currentDateIso, b.time) || parseTime(b.time) || new Date(8640000000000000000);
                     return (ta as Date).getTime() - (tb as Date).getTime();
                   });

                   if (entries.length === 0) {
                     return (<div class="finnish-empty">No available events</div>);
                   }

                    return (
                      <div>
                        {entries.map((athlete: FinnishAthlete) => (
                          <div class="finnish-event">
                            <div class="finnish-event-time"><span class="time" data-time={athlete.time} data-date-iso={athlete.dateIso || currentDateIso}>{formatTime(athlete.time)}</span></div>
                            <div class="finnish-event-details">
                              <h3>
                                {athlete.event}
                                {( ((athlete as any).status && /in\s*progress|in_progress|inprogress/i.test((athlete as any).status)) || isInProgressFromIso((athlete as any).eventIso || '', athlete.dateIso || currentDateIso, athlete.time || '') ) && <span class="in-progress-badge">LIVE</span>}
                                {( ((athlete as any).status && /finished|ended|completed/i.test((athlete as any).status)) || isEndedFromIso((athlete as any).eventIso || '', athlete.dateIso || currentDateIso, athlete.time || '') ) && <span class="ended-badge">EVENT ENDED</span>}
                              </h3>
                              <p class="finnish-athlete">{athlete.athlete}</p>
                              <p class="finnish-event-sport">{athlete.sport}</p>
                            </div>
                          </div>
                        ))}
                      </div>
                    );
                })()
              }
           </div>
            <!-- Past events (global) -->
            <div style="margin-top:12px;">
              <div class="section-title">Past events</div>
              <div class="schedule">
                {
                  (() => {
                    // Exclude global past events that correspond to Finnish athlete events to avoid duplication
                    const finnishEventNames = new Set(filteredFinnishAthletes.map(a => (a.event || '').trim().toLowerCase()).filter(Boolean));
                    const globalPast = pastEventsAll.filter(ev => !(finnishEventNames.has((ev.event || '').trim().toLowerCase())));
                    if (globalPast.length === 0) return (<div class="finnish-empty">No past events</div>);
                    return (
                      <div>
                        {globalPast.map((ev: ScheduleEvent) => (
                          <div class="finnish-event">
                            <div class="finnish-event-time"><span class="time" data-time={ev.time} data-date-iso={(ev as any).dateIso || currentDateIso}>{formatTime(ev.time)}</span></div>
                            <div class="finnish-event-details">
                              <h3>
                                {ev.event}
                                <span class="ended-badge">EVENT ENDED</span>
                              </h3>
                              <p class="finnish-event-sport">{ev.sport}</p>
                            </div>
                          </div>
                        ))}
                      </div>
                    );
                  })()
                }
              </div>
            </div>
        </div>

        <div class="main-column">
          <div class="section-title">Upcoming</div>
          <div class="schedule">
            {
              // split into Live Now and Upcoming lists
              (() => {
                const liveEvents = filteredEvents.filter((e: ScheduleEvent) => {
                  const status = ((e as any).status || '').toString();
                  if (status && /in\s*progress|in_progress|inprogress/i.test(status)) return true;
                  return isInProgressFromIso((e as any).eventIso || '', (e as any).dateIso || currentDateIso, e.time || '');
                });

                // Exclude events that are in-progress either via explicit status or ISO/time detection
                const upcomingEvents = filteredEvents.filter((e: ScheduleEvent) => {
                  const status = ((e as any).status || '').toString();
                  if (status && /in\s*progress|in_progress|inprogress/i.test(status)) return false;
                  return !isInProgressFromIso((e as any).eventIso || '', (e as any).dateIso || currentDateIso, e.time || '');
                });

                // Past events explicitly marked as finished/ended in the feed
                const pastEvents = (todaysEvents || []).filter((e: ScheduleEvent) => {
                  const status = ((e as any).status || '').toString();
                  return status && /finished|ended|completed/i.test(status);
                });

                // sort past by instant descending (newest first)
                pastEvents.sort((a: ScheduleEvent, b: ScheduleEvent) => {
                  const ta = parseEventInstant((a as any).eventIso || '', (a as any).dateIso || currentDateIso, a.time) || parseTime(a.time) || new Date(0);
                  const tb = parseEventInstant((b as any).eventIso || '', (b as any).dateIso || currentDateIso, b.time) || parseTime(b.time) || new Date(0);
                  return (tb as Date).getTime() - (ta as Date).getTime();
                });

                // sort upcoming by instant
                upcomingEvents.sort((a: ScheduleEvent, b: ScheduleEvent) => {
                  const ta = parseEventInstant((a as any).eventIso || '', (a as any).dateIso || currentDateIso, a.time) || parseTime(a.time) || new Date(8640000000000000);
                  const tb = parseEventInstant((b as any).eventIso || '', (b as any).dateIso || currentDateIso, b.time) || parseTime(b.time) || new Date(8640000000000000);
                  return (ta as Date).getTime() - (tb as Date).getTime();
                });

                if (upcomingEvents.length === 0 && pastEvents.length === 0) {
                  return (<div class="empty">No upcoming events</div>);
                }

                return (
                  <div>
                    <div>
                      {upcomingEvents.length > 0 && (
                        <div>
                          {upcomingEvents.map((event: ScheduleEvent) => (
                            <div class="event">
                              <div class="event-time"><span class="time" data-time={event.time} data-date-iso={(event as any).dateIso || currentDateIso}>{formatTime(event.time)}</span></div>
                              <div class="event-details">
                                <h3>
                                  {event.event}
                                  {event.status && /cancel/i.test(event.status) && (
                                    <span class="cancelled-badge">CANCELLED</span>
                                  )}
                                </h3>
                                <p class="event-sport">{event.sport}</p>
                                {event.venue && <p class="event-venue">üìç {event.venue}</p>}
                                {event.teams && <p class="event-teams">{addCountryEmoji(event.teams)}</p>}
                              </div>
                            </div>
                          ))}
                        </div>
                      )}

                      {/* Past events moved to the Finnish column */}
                    </div>
                  </div>
                );
              })()
            }
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
